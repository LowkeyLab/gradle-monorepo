package io.github.lowkeylab.freedsl.processor

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSType
import com.google.devtools.ksp.symbol.KSValueParameter
import com.google.devtools.ksp.symbol.Nullability
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.LambdaTypeName
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeName
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asClassName
import com.squareup.kotlinpoet.asTypeName
import kotlin.properties.Delegates

/**
 * Generates DSL builder code for data classes annotated with @FreeDsl.
 */
class DslBuilder(
    private val classDeclaration: KSClassDeclaration,
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger,
) {
    private val className = classDeclaration.simpleName.asString()
    private val packageName = classDeclaration.packageName.asString()
    private val builderClassName = "${className}Builder"
    private val constructorParameters = classDeclaration.primaryConstructor?.parameters ?: emptyList()

    /**
     * Generates the DSL builder code for the class.
     */
    fun generate() {
        logger.info("DslBuilder: Generating DSL builder for $className")

        try {
            // Get the fully qualified class name
            val fullClassName =
                classDeclaration.qualifiedName?.asString()
                    ?: throw IllegalArgumentException("Class must have a qualified name")
            val classType = ClassName.bestGuess(fullClassName)
            val builderType = ClassName.bestGuess("$packageName.$builderClassName")

            // Create the builder class
            val builderClass =
                TypeSpec
                    .classBuilder(builderClassName)
                    .addKdoc("Builder for [$className] that supports DSL syntax.")

            // Add properties for each constructor parameter
            constructorParameters.forEach { parameter ->
                val propertySpec = generatePropertySpec(parameter)
                builderClass.addProperty(propertySpec)
            }

            // Add nested builders for complex properties
            constructorParameters.forEach { parameter ->
                if (isNestedBuilderCandidate(parameter)) {
                    val nestedBuilderMethod = generateNestedBuilderMethodSpec(parameter)
                    builderClass.addFunction(nestedBuilderMethod)
                }
            }

            // Add build method
            val buildMethod = generateBuildMethodSpec(classType)
            builderClass.addFunction(buildMethod)

            // Create the DSL function
            val dslFunction = generateDslFunctionSpec(classType, builderType)

            // Create the file spec
            val fileSpecBuilder =
                FileSpec
                    .builder(packageName, "${className}DslBuilder")
                    .addFileComment("Generated by FreeDsl KSP processor")
                    .addImport(fullClassName.substringBeforeLast("."), fullClassName.substringAfterLast("."))

            // Add imports for all types used in properties
            constructorParameters.forEach { parameter ->
                val type = parameter.type.resolve()
                val typeName = type.declaration.qualifiedName?.asString() ?: return@forEach
                if (typeName != "kotlin.String" &&
                    typeName != "kotlin.Int" &&
                    typeName != "kotlin.Long" &&
                    typeName != "kotlin.Double" &&
                    typeName != "kotlin.Float" &&
                    typeName != "kotlin.Boolean" &&
                    typeName != "kotlin.Any" &&
                    !typeName.startsWith(packageName)
                ) {
                    fileSpecBuilder.addImport(typeName.substringBeforeLast("."), typeName.substringAfterLast("."))
                }

                // Add imports for generic type arguments
                type.arguments.forEach { arg ->
                    val argType = arg.type?.resolve() ?: return@forEach
                    val argTypeName = argType.declaration.qualifiedName?.asString() ?: return@forEach
                    if (argTypeName != "kotlin.String" &&
                        argTypeName != "kotlin.Int" &&
                        argTypeName != "kotlin.Long" &&
                        argTypeName != "kotlin.Double" &&
                        argTypeName != "kotlin.Float" &&
                        argTypeName != "kotlin.Boolean" &&
                        argTypeName != "kotlin.Any" &&
                        !argTypeName.startsWith(packageName)
                    ) {
                        fileSpecBuilder.addImport(
                            argTypeName.substringBeforeLast("."),
                            argTypeName.substringAfterLast("."),
                        )
                    }
                }
            }

            val fileSpec =
                fileSpecBuilder
                    .addType(builderClass.build())
                    .addFunction(dslFunction)
                    .build()

            // Write the generated code to a file
            val dependencies = Dependencies(true, classDeclaration.containingFile!!)

            codeGenerator
                .createNewFile(
                    dependencies = dependencies,
                    packageName = packageName,
                    fileName = "${className}DslBuilder.kt",
                ).use { outputStream ->
                    outputStream.writer().use { writer ->
                        fileSpec.writeTo(writer)
                    }
                }

            logger.info("DslBuilder: Successfully generated DSL builder for $className")
        } catch (e: Exception) {
            logger.error("DslBuilder: Error generating DSL builder for $className: ${e.message}")
            e.printStackTrace()
            throw e
        }
    }

    /**
     * Generates the builder class code.
     */
    private fun generateBuilderClass(builder: StringBuilder) {
        builder.appendLine("/**")
        builder.appendLine(" * Builder for [$className] that supports DSL syntax.")
        builder.appendLine(" */")
        builder.appendLine("class $builderClassName {")

        // Generate properties for each constructor parameter
        constructorParameters.forEach { parameter ->
            generateProperty(builder, parameter)
        }

        // Generate nested builders for complex properties
        constructorParameters.forEach { parameter ->
            if (isNestedBuilderCandidate(parameter)) {
                generateNestedBuilderMethod(builder, parameter)
            }
        }

        // Generate build method
        generateBuildMethod(builder)

        builder.appendLine("}")
        builder.appendLine()
    }

    /**
     * Generates a property for a constructor parameter.
     */
    private fun generateProperty(
        builder: StringBuilder,
        parameter: KSValueParameter,
    ) {
        val name = parameter.name?.asString() ?: return
        val type = parameter.type.resolve()
        val typeString = getTypeString(type)
        val isNullable = type.nullability == Nullability.NULLABLE
        val hasDefaultValue = parameter.hasDefault

        builder.append("    ")

        if (isNullable || hasDefaultValue) {
            // For nullable or parameters with default values, we can use simple var
            builder.appendLine("var $name: $typeString${if (isNullable) "?" else ""} = ${getDefaultValueForType(type)}")
        } else {
            // For required non-nullable parameters, use Delegates.notNull()
            builder.appendLine("var $name: $typeString by Delegates.notNull()")
        }
    }

    /**
     * Generates a PropertySpec for a constructor parameter.
     *
     * @param parameter The constructor parameter
     * @return The PropertySpec for the parameter
     */
    private fun generatePropertySpec(parameter: KSValueParameter): PropertySpec {
        val name = parameter.name?.asString() ?: throw IllegalArgumentException("Parameter must have a name")
        val type = parameter.type.resolve()
        val typeName = getTypeNameFromKSType(type)
        val isNullable = type.nullability == Nullability.NULLABLE
        val hasDefaultValue = parameter.hasDefault

        val propertyBuilder =
            PropertySpec
                .builder(name, typeName)
                .mutable(true) // Make it a var

        if (isNullable || hasDefaultValue) {
            // For nullable or parameters with default values, we can use simple var with initializer
            val defaultValue = getDefaultValueCodeBlock(type)
            propertyBuilder.initializer(defaultValue)
        } else {
            // For required non-nullable parameters, use Delegates.notNull()
            val delegateType = Delegates::class.asClassName()
            propertyBuilder.delegate("$delegateType.notNull()")
        }

        return propertyBuilder.build()
    }

    /**
     * Converts a KSType to a TypeName that can be used with KotlinPoet.
     *
     * @param type The KSType to convert
     * @return The corresponding TypeName
     */
    private fun getTypeNameFromKSType(type: KSType): TypeName {
        val declaration = type.declaration
        val typeName = declaration.qualifiedName?.asString() ?: return Any::class.asTypeName()
        val isNullable = type.nullability == Nullability.NULLABLE

        // Handle primitive types
        val primitiveTypeName =
            when (typeName) {
                "kotlin.String" -> String::class.asClassName()
                "kotlin.Int" -> Int::class.asClassName()
                "kotlin.Long" -> Long::class.asClassName()
                "kotlin.Double" -> Double::class.asClassName()
                "kotlin.Float" -> Float::class.asClassName()
                "kotlin.Boolean" -> Boolean::class.asClassName()
                "kotlin.Any" -> Any::class.asTypeName()
                else -> ClassName.bestGuess(typeName)
            }

        // If the type has no arguments, just return the type name
        if (type.arguments.isEmpty()) {
            return if (isNullable) primitiveTypeName.copy(nullable = true) else primitiveTypeName
        }

        // For generic types, include the type arguments
        val typeArgs =
            type.arguments.map { arg ->
                val argType = arg.type?.resolve()
                if (argType != null) {
                    getTypeNameFromKSType(argType)
                } else {
                    Any::class.asTypeName()
                }
            }

        val parameterizedTypeName = primitiveTypeName.parameterizedBy(typeArgs)
        return if (isNullable) parameterizedTypeName.copy(nullable = true) else parameterizedTypeName
    }

    /**
     * Gets a CodeBlock with the default value for a type.
     *
     * @param type The KSType to get the default value for
     * @return A CodeBlock with the default value
     */
    private fun getDefaultValueCodeBlock(type: KSType): CodeBlock =
        when (type.nullability) {
            Nullability.NULLABLE -> CodeBlock.of("null")
            else -> {
                val typeName = type.declaration.qualifiedName?.asString() ?: "Any"

                when {
                    typeName == "kotlin.String" -> CodeBlock.of("%S", "")
                    typeName == "kotlin.Int" -> CodeBlock.of("%L", 0)
                    typeName == "kotlin.Long" -> CodeBlock.of("%LL", 0)
                    typeName == "kotlin.Double" -> CodeBlock.of("%L", 0.0)
                    typeName == "kotlin.Float" -> CodeBlock.of("%Lf", 0.0)
                    typeName == "kotlin.Boolean" -> CodeBlock.of("%L", false)
                    typeName == "kotlin.collections.List" -> {
                        val typeArg =
                            getTypeNameFromKSType(
                                type.arguments
                                    .first()
                                    .type!!
                                    .resolve(),
                            )
                        CodeBlock.of("emptyList<%T>()", typeArg)
                    }

                    typeName == "kotlin.Array" -> {
                        val typeArg =
                            getTypeNameFromKSType(
                                type.arguments
                                    .first()
                                    .type!!
                                    .resolve(),
                            )
                        CodeBlock.of("emptyArray<%T>()", typeArg)
                    }

                    typeName == "kotlin.collections.Map" -> {
                        val keyType = getTypeNameFromKSType(type.arguments[0].type!!.resolve())
                        val valueType = getTypeNameFromKSType(type.arguments[1].type!!.resolve())
                        CodeBlock.of("emptyMap<%T, %T>()", keyType, valueType)
                    }

                    typeName == "kotlin.collections.Set" -> {
                        val typeArg =
                            getTypeNameFromKSType(
                                type.arguments
                                    .first()
                                    .type!!
                                    .resolve(),
                            )
                        CodeBlock.of("emptySet<%T>()", typeArg)
                    }

                    else ->
                        CodeBlock.of(
                            "null as %T",
                            getTypeNameFromKSType(type),
                        ) // This is a fallback and might not compile
                }
            }
        }

    /**
     * Gets a string representation of a type, including generic type arguments.
     */
    private fun getTypeString(type: KSType): String {
        val typeName = type.declaration.qualifiedName?.asString() ?: "Any"

        // If the type has no arguments, just return the type name
        if (type.arguments.isEmpty()) {
            return typeName
        }

        // For generic types, include the type arguments
        val typeArgs =
            type.arguments.joinToString(", ") { arg ->
                val argType = arg.type?.resolve()
                if (argType != null) {
                    getTypeString(argType) + if (argType.nullability == Nullability.NULLABLE) "?" else ""
                } else {
                    "Any"
                }
            }

        return "$typeName<$typeArgs>"
    }

    /**
     * Generates a nested builder method for complex properties.
     */
    private fun generateNestedBuilderMethod(
        builder: StringBuilder,
        parameter: KSValueParameter,
    ) {
        val name = parameter.name?.asString() ?: return
        val type = parameter.type.resolve()
        val typeName = type.declaration.qualifiedName?.asString() ?: return
        val isNullable = type.nullability == Nullability.NULLABLE

        builder.appendLine()
        builder.appendLine("    /**")
        builder.appendLine("     * Configure the [$name] property using DSL syntax.")
        builder.appendLine("     */")

        if (isNullable) {
            builder.appendLine("    fun $name(block: ${typeName.removeSuffix("?")}Builder.() -> Unit) {")
            builder.appendLine("        val builder = ${typeName.removeSuffix("?")}Builder()")
            builder.appendLine("        builder.block()")
            builder.appendLine("        this.$name = builder.build()")
            builder.appendLine("    }")
        } else {
            builder.appendLine("    fun $name(block: ${typeName}Builder.() -> Unit) {")
            builder.appendLine("        val builder = ${typeName}Builder()")
            builder.appendLine("        builder.block()")
            builder.appendLine("        this.$name = builder.build()")
            builder.appendLine("    }")
        }
    }

    /**
     * Generates a FunSpec for a nested builder method.
     *
     * @param parameter The parameter to generate a nested builder method for
     * @return The FunSpec for the nested builder method
     */
    private fun generateNestedBuilderMethodSpec(parameter: KSValueParameter): FunSpec {
        val name = parameter.name?.asString() ?: throw IllegalArgumentException("Parameter must have a name")
        val type = parameter.type.resolve()
        val typeName =
            type.declaration.qualifiedName?.asString() ?: throw IllegalArgumentException("Parameter must have a type")
        val isNullable = type.nullability == Nullability.NULLABLE

        // Create the builder class name
        val builderClassName =
            if (isNullable) {
                "${typeName.removeSuffix("?")}Builder"
            } else {
                "${typeName}Builder"
            }
        val builderClassType = ClassName.bestGuess(builderClassName)

        // Create the lambda type for the block parameter
        val lambdaType =
            LambdaTypeName.get(
                receiver = builderClassType,
                returnType = Unit::class.asClassName(),
            )

        // Create the function
        return FunSpec
            .builder(name)
            .addKdoc("Configure the [$name] property using DSL syntax.")
            .addParameter("block", lambdaType)
            .addStatement("val builder = %T()", builderClassType)
            .addStatement("builder.block()")
            .addStatement("this.%N = builder.build()", name)
            .build()
    }

    /**
     * Generates the build method that creates an instance of the class.
     */
    private fun generateBuildMethod(builder: StringBuilder) {
        builder.appendLine()
        builder.appendLine("    /**")
        builder.appendLine("     * Builds an instance of [$className] with the configured properties.")
        builder.appendLine("     */")
        builder.appendLine("    fun build(): $className {")
        builder.append("        return $className(")

        // Add constructor parameters
        constructorParameters.forEachIndexed { index, parameter ->
            val name = parameter.name?.asString() ?: return@forEachIndexed
            builder.append("$name = $name")
            if (index < constructorParameters.size - 1) {
                builder.append(", ")
            }
        }

        builder.appendLine(")")
        builder.appendLine("    }")
    }

    /**
     * Generates a FunSpec for the build method.
     *
     * @param classType The TypeName for the class
     * @return The FunSpec for the build method
     */
    private fun generateBuildMethodSpec(classType: TypeName = ClassName.bestGuess(className)): FunSpec {
        // Create the function
        val funBuilder =
            FunSpec
                .builder("build")
                .addKdoc("Builds an instance of [$className] with the configured properties.")
                .returns(classType)

        // Build the constructor call with named parameters
        val codeBlockBuilder = CodeBlock.builder().add("return %T(\n", classType)

        // Add constructor parameters
        constructorParameters.forEachIndexed { index, parameter ->
            val name = parameter.name?.asString() ?: return@forEachIndexed
            codeBlockBuilder.add("    %N = %N", name, name)
            if (index < constructorParameters.size - 1) {
                codeBlockBuilder.add(",\n")
            } else {
                codeBlockBuilder.add("\n")
            }
        }

        codeBlockBuilder.add(")")

        funBuilder.addCode(codeBlockBuilder.build())

        return funBuilder.build()
    }

    /**
     * Generates the DSL function that creates and configures a builder.
     */
    private fun generateDslFunction(builder: StringBuilder) {
        val functionName = className.decapitalize()

        builder.appendLine("/**")
        builder.appendLine(" * Creates a [$className] using DSL syntax.")
        builder.appendLine(" */")
        builder.appendLine("fun $functionName(block: $builderClassName.() -> Unit): $className {")
        builder.appendLine("    val builder = $builderClassName()")
        builder.appendLine("    builder.block()")
        builder.appendLine("    return builder.build()")
        builder.appendLine("}")
    }

    /**
     * Generates a FunSpec for the DSL function.
     *
     * @param classType The TypeName for the class
     * @param builderType The TypeName for the builder class
     * @return The FunSpec for the DSL function
     */
    private fun generateDslFunctionSpec(
        classType: TypeName = ClassName.bestGuess(className),
        builderType: TypeName = ClassName.bestGuess(builderClassName),
    ): FunSpec {
        val functionName = className.decapitalize()

        // Create the lambda type for the block parameter
        val lambdaType =
            LambdaTypeName.get(
                receiver = builderType,
                returnType = Unit::class.asClassName(),
            )

        // Create the function
        return FunSpec
            .builder(functionName)
            .addKdoc("Creates a [$className] using DSL syntax.")
            .addParameter("block", lambdaType)
            .returns(classType)
            .addStatement("val builder = %T()", builderType)
            .addStatement("builder.block()")
            .addStatement("return builder.build()")
            .build()
    }

    /**
     * Determines if a parameter should have a nested builder.
     */
    private fun isNestedBuilderCandidate(parameter: KSValueParameter): Boolean {
        val type = parameter.type.resolve()
        val declaration = type.declaration

        // Check if it's a data class (potential nested builder)
        if (declaration is KSClassDeclaration) {
            return declaration.modifiers.any { it.toString() == "data" }
        }

        return false
    }

    /**
     * Gets the default value for a type.
     */
    private fun getDefaultValueForType(type: KSType): String =
        when (type.nullability) {
            Nullability.NULLABLE -> "null"
            else -> {
                val typeName = type.declaration.qualifiedName?.asString() ?: "Any"
                val typeString = getTypeString(type)

                when {
                    typeName == "kotlin.String" -> "\"\""
                    typeName == "kotlin.Int" -> "0"
                    typeName == "kotlin.Long" -> "0L"
                    typeName == "kotlin.Double" -> "0.0"
                    typeName == "kotlin.Float" -> "0.0f"
                    typeName == "kotlin.Boolean" -> "false"
                    typeName == "kotlin.collections.List" -> "emptyList<${getTypeArgString(type)}>()"
                    typeName == "kotlin.Array" -> "emptyArray<${getTypeArgString(type)}>()"
                    typeName == "kotlin.collections.Map" -> "emptyMap<${getMapTypeArgString(type)}>()"
                    typeName == "kotlin.collections.Set" -> "emptySet<${getTypeArgString(type)}>()"
                    else -> "null as $typeString" // This is a fallback and might not compile
                }
            }
        }

    /**
     * Gets a string representation of a type's first type argument.
     */
    private fun getTypeArgString(type: KSType): String {
        if (type.arguments.isEmpty()) {
            return "Any"
        }

        val arg = type.arguments.first()
        val argType = arg.type?.resolve()
        return if (argType != null) {
            getTypeString(argType) + if (argType.nullability == Nullability.NULLABLE) "?" else ""
        } else {
            "Any"
        }
    }

    /**
     * Gets a string representation of a Map's key and value type arguments.
     */
    private fun getMapTypeArgString(type: KSType): String {
        if (type.arguments.size < 2) {
            return "Any, Any"
        }

        val keyArg = type.arguments[0]
        val valueArg = type.arguments[1]

        val keyType = keyArg.type?.resolve()
        val valueType = valueArg.type?.resolve()

        val keyString =
            if (keyType != null) {
                getTypeString(keyType) + if (keyType.nullability == Nullability.NULLABLE) "?" else ""
            } else {
                "Any"
            }

        val valueString =
            if (valueType != null) {
                getTypeString(valueType) + if (valueType.nullability == Nullability.NULLABLE) "?" else ""
            } else {
                "Any"
            }

        return "$keyString, $valueString"
    }

    /**
     * Decapitalizes the first character of a string.
     */
    private fun String.decapitalize(): String {
        if (isEmpty() || !first().isUpperCase()) return this
        return first().lowercase() + substring(1)
    }
}
